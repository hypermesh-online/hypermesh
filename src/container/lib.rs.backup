//! HyperMesh Container Runtime
//!
//! Secure, high-performance container runtime with hardware-assisted virtualization,
//! capability-based security, and microsecond-level resource control.
//!
//! # Key Features
//! - OCI-compatible container lifecycle management
//! - Hardware-assisted virtualization support (Intel VT-x/AMD-V simulation)
//! - Capability-based security model with fine-grained permissions
//! - Live migration with <100ms downtime
//! - <100ms container startup time
//! - Copy-on-write filesystem with ZSTD compression
//! - Real-time resource monitoring and enforcement

#![warn(missing_docs)]
#![deny(unsafe_code)]

// Core modules
pub mod runtime;
pub mod lifecycle;
pub mod image;
pub mod network;
pub mod filesystem;
pub mod resources;
pub mod migration;
pub mod monitoring;
pub mod config;
pub mod error;

// Re-exports
pub use runtime::{ContainerRuntime, ContainerHandle};
pub use lifecycle::{ContainerState, ContainerLifecycle};
pub use image::{ImageManager, ContainerImage};
pub use network::{ContainerNetwork, NetworkNamespace};
pub use filesystem::{ContainerFilesystem, CowLayer};
pub use resources::{ResourceManager, ResourceQuota};
pub use migration::{MigrationManager, MigrationRequest};
pub use monitoring::{ContainerMonitor, ContainerMetrics};
pub use config::ContainerConfig;
pub use error::{ContainerError, Result};

use serde::{Serialize, Deserialize};
use std::collections::HashMap;
use std::path::PathBuf;
use std::time::{Duration, SystemTime};
use uuid::Uuid;

/// Unique identifier for containers
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct ContainerId(Uuid);

impl ContainerId {
    /// Generate a new container ID
    pub fn new() -> Self {
        Self(Uuid::new_v4())
    }
    
    /// Get the UUID
    pub fn as_uuid(&self) -> &Uuid {
        &self.0
    }
}

impl std::fmt::Display for ContainerId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

/// Container specification following OCI standard
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ContainerSpec {
    /// Container image reference
    pub image: String,
    /// Command to execute in container
    pub command: Vec<String>,
    /// Environment variables
    pub environment: HashMap<String, String>,
    /// Working directory
    pub working_dir: Option<PathBuf>,
    /// Resource limits
    pub resources: ResourceQuota,
    /// Network configuration
    pub network: NetworkConfig,
    /// Filesystem mounts
    pub mounts: Vec<MountConfig>,
    /// Security configuration
    pub security: SecurityConfig,
}

/// Network configuration for container
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkConfig {
    /// Network mode (bridge, host, none)
    pub mode: NetworkMode,
    /// Port mappings
    pub ports: Vec<PortMapping>,
    /// DNS configuration
    pub dns: Vec<String>,
}

/// Network modes
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NetworkMode {
    /// Bridge networking with virtual interface
    Bridge,
    /// Host networking (share host network stack)
    Host,
    /// No networking
    None,
    /// Custom network namespace
    Custom(String),
}

/// Port mapping configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PortMapping {
    /// Container port
    pub container_port: u16,
    /// Host port
    pub host_port: u16,
    /// Protocol (tcp, udp)
    pub protocol: Protocol,
}

/// Network protocols
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Protocol {
    /// TCP protocol
    Tcp,
    /// UDP protocol
    Udp,
}

/// Filesystem mount configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MountConfig {
    /// Source path (host)
    pub source: PathBuf,
    /// Target path (container)
    pub target: PathBuf,
    /// Mount type
    pub mount_type: MountType,
    /// Mount options
    pub options: Vec<String>,
}

/// Mount types
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum MountType {
    /// Bind mount
    Bind,
    /// Volume mount
    Volume,
    /// Temporary filesystem
    Tmpfs,
}

/// Security configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SecurityConfig {
    /// Linux capabilities
    pub capabilities: Vec<String>,
    /// User ID
    pub user_id: Option<u32>,
    /// Group ID
    pub group_id: Option<u32>,
    /// SELinux context
    pub selinux_label: Option<String>,
    /// AppArmor profile
    pub apparmor_profile: Option<String>,
    /// Read-only root filesystem
    pub read_only_rootfs: bool,
}

/// Container creation options
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateOptions {
    /// Container name (optional)
    pub name: Option<String>,
    /// Labels
    pub labels: HashMap<String, String>,
    /// Auto-start container
    pub auto_start: bool,
    /// Remove container on exit
    pub auto_remove: bool,
}

/// Default implementations
impl Default for ContainerId {
    fn default() -> Self {
        Self::new()
    }
}

impl Default for CreateOptions {
    fn default() -> Self {
        Self {
            name: None,
            labels: HashMap::new(),
            auto_start: false,
            auto_remove: false,
        }
    }
}

impl Default for NetworkConfig {
    fn default() -> Self {
        Self {
            mode: NetworkMode::Bridge,
            ports: Vec::new(),
            dns: vec!["8.8.8.8".to_string(), "8.8.4.4".to_string()],
        }
    }
}

impl Default for SecurityConfig {
    fn default() -> Self {
        Self {
            capabilities: vec!["CAP_NET_BIND_SERVICE".to_string()],
            user_id: None,
            group_id: None,
            selinux_label: None,
            apparmor_profile: None,
            read_only_rootfs: false,
        }
    }
}